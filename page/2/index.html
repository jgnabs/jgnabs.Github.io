<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"AL8WZYWIU5","apiKey":"cd3eeb6b327eb1799d492c071a089d71","indexName":"hexo_algolia","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="秀外慧中流砥柱">
<meta property="og:type" content="website">
<meta property="og:title" content="SpaceX">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="SpaceX">
<meta property="og:description" content="秀外慧中流砥柱">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="SpaceX">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>SpaceX</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">SpaceX</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">人生苦短，先学Java</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="search-pop-overlay">
  <div class="popup search-popup">
      <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

    
  </div>
</div>

  </div>
</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/25/python-grammar-notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SpaceX">
      <meta itemprop="description" content="秀外慧中流砥柱">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpaceX">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/11/25/python-grammar-notes/" class="post-title-link" itemprop="url">python特殊语法笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-11-25 10:08:20" itemprop="dateCreated datePublished" datetime="2017-11-25T10:08:20+08:00">2017-11-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Beautiful is better than ugly.<br>Explicit is better than implicit.<br>Simple is better than complex.<br>Complex is better than complicated.<br>Flat is better than nested.<br>Sparse is better than dense.<br>Readability counts.<br>Special cases aren’t special enough to break the rules.<br>Although practicality beats purity.<br>Errors should never pass silently.<br>Unless explicitly silenced.<br>In the face of ambiguity, refuse the temptation to guess.<br>There should be one– and preferably only one –obvious way to do it.<br>Although that way may not be obvious at first unless you’re Dutch.<br>Now is better than never.<br>Although never is often better than <em>right</em> now.<br>If the implementation is hard to explain, it’s a bad idea.<br>If the implementation is easy to explain, it may be a good idea.<br>Namespaces are one honking great idea – let’s do more of those!   </p>
<p>优美胜于丑陋（Python 以编写优美的代码为目标）<br>明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）<br>简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）<br>复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）<br>扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）<br>间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）<br>可读性很重要（优美的代码是可读的）<br>即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）<br>不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写 except:pass 风格的代码）<br>当存在多种可能，不要尝试去猜测<br>而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）<br>虽然这并不容易，因为你不是 Python 之父（这里的 Dutch 是指 Guido ）<br>做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量）<br>如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准）<br>命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）   </p>
<h2 id="数据类型和关键字"><a href="#数据类型和关键字" class="headerlink" title="数据类型和关键字"></a>数据类型和关键字</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="字符串变量的索引"><a href="#字符串变量的索引" class="headerlink" title="字符串变量的索引"></a>字符串变量的索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">word &#x3D; &#39;Python&#39;</span><br><span class="line">word[0]  #位置0的字符</span><br><span class="line">&#39;P&#39;</span><br><span class="line">word[5]  #位置5的字符</span><br><span class="line">&#39;n&#39;</span><br><span class="line">word[-1]  #最后一个字符</span><br><span class="line">&#39;n&#39;</span><br><span class="line">word[:2] + word[2:]</span><br><span class="line">&#39;Python&#39;</span><br><span class="line">word[:4] + word[4:]</span><br><span class="line">&#39;Python&#39;</span><br><span class="line">word[:2]   # 从0到字符串2的字符串</span><br><span class="line">&#39;Py&#39;</span><br><span class="line">word[4:]   # 从4到len(word)</span><br><span class="line">&#39;on&#39;</span><br><span class="line">word[-2:]  # 从前往后数第二个到最后end</span><br><span class="line">&#39;on&#39;</span><br></pre></td></tr></table></figure>

<h4 id="原始字符串-不需反斜杠转义"><a href="#原始字符串-不需反斜杠转义" class="headerlink" title="原始字符串(不需反斜杠转义)"></a>原始字符串(不需反斜杠转义)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用一个r单字符写在变量值之前</span></span><br><span class="line">str = <span class="string">r'D:\soooooooft\python_install'</span></span><br><span class="line">print(str)</span><br><span class="line"><span class="string">'D:\soooooooft\python_install'</span></span><br></pre></td></tr></table></figure>

<h4 id="的应用"><a href="#的应用" class="headerlink" title="_的应用"></a><code>_</code>的应用</h4><blockquote>
<p> 在交互模式中，最后一个有关打印的表达式的值会赋值给变量<code>_</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tax &#x3D; 12.5 &#x2F; 100</span><br><span class="line">&gt;&gt;&gt; price &#x3D; 100.50</span><br><span class="line">&gt;&gt;&gt; price * tax</span><br><span class="line">12.5625</span><br><span class="line">&gt;&gt;&gt; price + _</span><br><span class="line">113.0625</span><br><span class="line">&gt;&gt;&gt; round(_, 2)</span><br><span class="line">113.06</span><br></pre></td></tr></table></figure>


<h4 id="字符串的多行赋值"><a href="#字符串的多行赋值" class="headerlink" title="字符串的多行赋值"></a>字符串的多行赋值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;&quot;&quot;\    #可测试没有改换行符的情景</span><br><span class="line">Usage: thingy [OPTIONS]</span><br><span class="line">     -h                        Display this usage message</span><br><span class="line">     -H hostname               Hostname to connect to</span><br><span class="line">&quot;&quot;&quot;)</span><br></pre></td></tr></table></figure>


<h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><h4 id="数字处理"><a href="#数字处理" class="headerlink" title="数字处理"></a>数字处理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">number_a = <span class="number">5.99</span></span><br><span class="line">number_b = int(a)</span><br><span class="line">print(number_b)   <span class="comment">#输出5</span></span><br><span class="line">print(<span class="number">17</span> // <span class="number">3</span>)  <span class="comment"># 输出5，丢弃小数部分。</span></span><br><span class="line">print(<span class="number">5</span> ** <span class="number">2</span>)   <span class="comment">#5的2次方,25</span></span><br></pre></td></tr></table></figure>

<h3 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h3><p>集合类型十分的强大，最常见的就是list类型，和str有很多的共性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span><br><span class="line">n &#x3D; [1, 2, 3]</span><br><span class="line">x &#x3D; [a, n]</span><br><span class="line">x</span><br><span class="line">[[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], [1, 2, 3]]</span><br><span class="line">x[0]</span><br><span class="line">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span><br><span class="line">x[0][1]</span><br><span class="line">&#39;b&#39;</span><br></pre></td></tr></table></figure>

<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="end的使用-避免打印新行"><a href="#end的使用-避免打印新行" class="headerlink" title="end的使用 避免打印新行"></a>end的使用 避免打印新行</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> b &lt; <span class="number">1000</span>:</span><br><span class="line"><span class="meta">... </span>    print(b, end=<span class="string">','</span>)</span><br><span class="line"><span class="meta">... </span>    a, b = b, a+b</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">34</span>,<span class="number">55</span>,<span class="number">89</span>,<span class="number">144</span>,<span class="number">233</span>,<span class="number">377</span>,<span class="number">610</span>,<span class="number">987</span>,</span><br></pre></td></tr></table></figure>

<h2 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h2><h3 id="if语句（使用elif代替其他编程语言的else-if，减少冗余的缩进）"><a href="#if语句（使用elif代替其他编程语言的else-if，减少冗余的缩进）" class="headerlink" title="if语句（使用elif代替其他编程语言的else if，减少冗余的缩进）"></a>if语句（使用elif代替其他编程语言的else if，减少冗余的缩进）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = int(input(<span class="string">"Please enter an integer: "</span>))</span><br><span class="line">Please enter an integer: <span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>    x = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Negative changed to zero'</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">elif</span> x == <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Zero'</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">elif</span> x == <span class="number">1</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Single'</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'More'</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="for语句（只能在子语句中终结循环）"><a href="#for语句（只能在子语句中终结循环）" class="headerlink" title="for语句（只能在子语句中终结循环）"></a>for语句（只能在子语句中终结循环）</h3><p>在遍历子语句中操作这个循环对象，建议使用切片符号进行显示的对象拷贝。比如下面两种情况：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> w <span class="keyword">in</span> words[:]:  <span class="comment"># Loop over a slice copy of the entire list.</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> len(w) &gt; <span class="number">6</span>:</span><br><span class="line"><span class="meta">... </span>        words.insert(<span class="number">0</span>, w)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>words</span><br><span class="line">[<span class="string">'defenestrate'</span>, <span class="string">'cat'</span>, <span class="string">'window'</span>, <span class="string">'defenestrate'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果是下面这种，插入操作将会一直不停的执行。永远不会结束。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> len(w) &gt; <span class="number">6</span>:</span><br><span class="line"><span class="meta">... </span>        words.insert(<span class="number">0</span>, w)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>words</span><br><span class="line">[<span class="string">'defenestrate'</span>, <span class="string">'cat'</span>, <span class="string">'window'</span>, <span class="string">'defenestrate'</span>]</span><br></pre></td></tr></table></figure>

<h3 id="range函数"><a href="#range函数" class="headerlink" title="range函数"></a>range函数</h3><p>遍历一个数字类型的序列使用range函数将会很方便，支持等差数的遍历。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">range(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">   <span class="number">5</span> through <span class="number">9</span></span><br><span class="line"></span><br><span class="line">range(<span class="number">0</span>, <span class="number">10</span>, <span class="number">3</span>)</span><br><span class="line">   <span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span></span><br><span class="line"></span><br><span class="line">range(<span class="number">-10</span>, <span class="number">-100</span>, <span class="number">-30</span>)</span><br><span class="line">  <span class="number">-10</span>, <span class="number">-40</span>, <span class="number">-70</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">'Mary'</span>, <span class="string">'had'</span>, <span class="string">'a'</span>, <span class="string">'little'</span>, <span class="string">'lamb'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line"><span class="meta">... </span>    print(i, a[i])</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> Mary</span><br><span class="line"><span class="number">1</span> had</span><br><span class="line"><span class="number">2</span> a</span><br><span class="line"><span class="number">3</span> little</span><br><span class="line"><span class="number">4</span> lamb</span><br></pre></td></tr></table></figure>

<p>循环块中可以有else语句，当for循环结束后，或者while条件为false后执行，但是当break跳出循环的时候是不会执行else的。比如一个求质数的例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> n % x == <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>            print(n, <span class="string">'equals'</span>, x, <span class="string">'*'</span>, n//x)</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">break</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="comment"># for遍历完成并且没有找到一个因数</span></span><br><span class="line"><span class="meta">... </span>        print(n, <span class="string">'is a prime number'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="number">2</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">3</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">4</span> equals <span class="number">2</span> * <span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">6</span> equals <span class="number">2</span> * <span class="number">3</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">8</span> equals <span class="number">2</span> * <span class="number">4</span></span><br><span class="line"><span class="number">9</span> equals <span class="number">3</span> * <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><p>def关键字定义一个函数，后面跟形参，方法内容从下一行开始，必须缩进。<br>每一个函数都会返回一个值，即使他没有返回（return）语句，没有返回语句的会返回None。</p>
<h3 id="函数的可变长度形参传递和参数默认值设置"><a href="#函数的可变长度形参传递和参数默认值设置" class="headerlink" title="函数的可变长度形参传递和参数默认值设置"></a>函数的可变长度形参传递和参数默认值设置</h3><blockquote>
<p>定义一个函数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ask_ok</span><span class="params">(prompt, retries=<span class="number">4</span>, reminder=<span class="string">'Please try again!'</span>)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ok = input(prompt)</span><br><span class="line">        <span class="keyword">if</span> ok <span class="keyword">in</span> (<span class="string">'y'</span>, <span class="string">'ye'</span>, <span class="string">'yes'</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> ok <span class="keyword">in</span> (<span class="string">'n'</span>, <span class="string">'no'</span>, <span class="string">'nop'</span>, <span class="string">'nope'</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        retries = retries - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> retries &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'invalid user response'</span>)</span><br><span class="line">        print(reminder)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>调用函数时，我们可以认为拥有默认值的参数是可以不参与参数传递的。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ask_ok(<span class="string">'Do you really want to quit?'</span>)</span><br><span class="line">ask_ok(<span class="string">'OK to overwrite the file?'</span>, <span class="number">2</span>)</span><br><span class="line">ask_ok(<span class="string">'OK to overwrite the file?'</span>, <span class="number">2</span>, <span class="string">'Come on, only yes or no!'</span>)</span><br></pre></td></tr></table></figure>

<p>在方法定义层面，上述方法的调用有一个参数是必须要传递的（required argument），有三个是可选（optional arguments）的 (三个可选参数：state,action,type)<br>在调用方法层面，又可以分为 键值参数（keyword arguments）和位置参数（positional arguments）。如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parrot</span><span class="params">(voltage, state=<span class="string">'a stiff'</span>, action=<span class="string">'voom'</span>, type=<span class="string">'Norwegian Blue'</span>)</span>:</span></span><br><span class="line">    print(<span class="string">"-- This parrot wouldn't"</span>, action, end=<span class="string">' '</span>)</span><br><span class="line">    print(<span class="string">"if you put"</span>, voltage, <span class="string">"volts through it."</span>)</span><br><span class="line">    print(<span class="string">"-- Lovely plumage, the"</span>, type)</span><br><span class="line">    print(<span class="string">"-- It's"</span>, state, <span class="string">"!"</span>)</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">方法调用时，值得注意的是，位置参数必须在键值参数之前：</span><br><span class="line">parrot(<span class="number">1000</span>)                                          <span class="comment"># 1 positional argument</span></span><br><span class="line">parrot(voltage=<span class="number">1000</span>)                                  <span class="comment"># 1 keyword argument</span></span><br><span class="line">parrot(voltage=<span class="number">1000000</span>, action=<span class="string">'VOOOOOM'</span>)             <span class="comment"># 2 keyword arguments</span></span><br><span class="line">parrot(action=<span class="string">'VOOOOOM'</span>, voltage=<span class="number">1000000</span>)             <span class="comment"># 2 keyword arguments</span></span><br><span class="line">parrot(<span class="string">'a million'</span>, <span class="string">'bereft of life'</span>, <span class="string">'jump'</span>)         <span class="comment"># 3 positional arguments</span></span><br><span class="line">parrot(<span class="string">'a thousand'</span>, state=<span class="string">'pushing up the daisies'</span>)  <span class="comment"># 1 positional, 1 keyword</span></span><br></pre></td></tr></table></figure>


<h3 id="可变长位置参数和可变长键值参数传递"><a href="#可变长位置参数和可变长键值参数传递" class="headerlink" title="可变长位置参数和可变长键值参数传递"></a>可变长位置参数和可变长键值参数传递</h3><p><strong>name代表任意长度的键值参数传递，<em>name代表任意长度的位置参数传递，</em>name必须在</strong>name之前，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cheeseshop</span><span class="params">(kind, *arguments, **keywords)</span>:</span></span><br><span class="line">    print(<span class="string">"-- Do you have any"</span>, kind, <span class="string">"?"</span>)</span><br><span class="line">    print(<span class="string">"-- I'm sorry, we're all out of"</span>, kind)</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> arguments:</span><br><span class="line">        print(arg)</span><br><span class="line">    print(<span class="string">"-"</span> * <span class="number">40</span>)</span><br><span class="line">    <span class="keyword">for</span> kw <span class="keyword">in</span> keywords:</span><br><span class="line">        print(kw, <span class="string">":"</span>, keywords[kw])</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">调用方法：</span><br><span class="line">cheeseshop(<span class="string">"Limburger"</span>, <span class="string">"It's very runny, sir."</span>,</span><br><span class="line">           <span class="string">"It's really very, VERY runny, sir."</span>,</span><br><span class="line">           shopkeeper=<span class="string">"Michael Palin"</span>,</span><br><span class="line">           client=<span class="string">"John Cleese"</span>,</span><br><span class="line">           sketch=<span class="string">"Cheese Shop Sketch"</span>)</span><br><span class="line">		   </span><br><span class="line">		   </span><br><span class="line">打印结果：</span><br><span class="line">-- Do you have any Limburger ?</span><br><span class="line">-- I<span class="string">'m sorry, we'</span>re all out of Limburger</span><br><span class="line">It<span class="string">'s very runny, sir.</span></span><br><span class="line"><span class="string">It'</span>s really very, VERY runny, sir.</span><br><span class="line">----------------------------------------</span><br><span class="line">shopkeeper : Michael Palin</span><br><span class="line">client : John Cleese</span><br><span class="line">sketch : Cheese Shop Sketch</span><br></pre></td></tr></table></figure>

<blockquote>
<p>另外，初始值只会在定义域初始化方法的时候计算一次，如果是可变对象如list和class实例，字典等的话会出现如下类似场景。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, L=[])</span>:</span></span><br><span class="line">    L.append(a)</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line">print(f(<span class="number">1</span>))</span><br><span class="line">print(f(<span class="number">2</span>))</span><br><span class="line">print(f(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">打印结果对应如下：</span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>


<h2 id="python中的数据结构"><a href="#python中的数据结构" class="headerlink" title="python中的数据结构"></a>python中的数据结构</h2><h3 id="使用list作为stack"><a href="#使用list作为stack" class="headerlink" title="使用list作为stack"></a>使用list作为stack</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack.append(<span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack.append(<span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack.pop()</span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack.pop()</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack.pop()</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h3 id="使用list作为queue"><a href="#使用list作为queue" class="headerlink" title="使用list作为queue"></a>使用list作为queue</h3><p>在队列中，list结尾的添加和弹出是很快的，但是list开头的插入和弹出是很慢的。<br>python为了提升队列的效率，python设计出了collections.deque，使用如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue = deque([<span class="string">"Eric"</span>, <span class="string">"John"</span>, <span class="string">"Michael"</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue.append(<span class="string">"Terry"</span>)           <span class="comment"># Terry arrives</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue.append(<span class="string">"Graham"</span>)          <span class="comment"># Graham arrives</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue.popleft()                 <span class="comment"># The first to arrive now leaves</span></span><br><span class="line"><span class="string">'Eric'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue.popleft()                 <span class="comment"># The second to arrive now leaves</span></span><br><span class="line"><span class="string">'John'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue                           <span class="comment"># Remaining queue in order of arrival</span></span><br><span class="line">deque([<span class="string">'Michael'</span>, <span class="string">'Terry'</span>, <span class="string">'Graham'</span>])</span><br></pre></td></tr></table></figure>

<h3 id="递推式构造列表（List-Comprehensions）"><a href="#递推式构造列表（List-Comprehensions）" class="headerlink" title="递推式构造列表（List Comprehensions）"></a>递推式构造列表（List Comprehensions）</h3><h2 id="高级定义"><a href="#高级定义" class="headerlink" title="高级定义"></a>高级定义</h2><h3 id="if-name-‘-main-‘-的含义"><a href="#if-name-‘-main-‘-的含义" class="headerlink" title="if _name_ == ‘_main_‘ 的含义"></a>if _<em>name_</em> == ‘_<em>main_</em>‘ 的含义</h3><p>一个 Python 源码文件除了可以被直接运行外，还可以作为模块（也就是库）被导入。不管是导入还是直接运行，最顶层的代码都会被运行（Python 用缩进来区分代码层次）。而实际上在导入的时候，有一部分代码我们是不希望被运行的。<br>例如如下代码我们只想在当做独立脚本的时候运行main()方法,其他模块import该模块的时候不想运行main()方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PI = <span class="number">3.14L</span>EGB</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"PI:"</span>, PI</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p>if _<em>name_</em> == ‘_<em>main_</em>‘则可以很顺畅的解决该问题。<br>_<em>name_<em>是一个导入相关的模块内置属性。该属性不可刻意使用，它是每一个模块的全限定名称，在导入系统（THE IMPORT SYSTEM）中只能并且可以标识一个模块。<br>如果一个模块被直接运行（直接或者间接称成为顶级代码[top-level code]运行时），则其没有包结构，其 __name\</em></em> 值为 __main__。</p>
<h3 id="CLASS描述"><a href="#CLASS描述" class="headerlink" title="CLASS描述"></a>CLASS描述</h3><p>名字空间(Namespaces)</p>
<blockquote>
<p>一些语言中比如c,c++,java 变量名是内存地址别名, 而Python的名字就是一个字符串，它与所指向的目标对象关联构成名字空间里面的一个键值对{name: object}，因此可以这么说，python的名字空间就是一个字典。<br>python里面有很多名字空间，每个地方都有自己的名字空间，互不干扰，不同空间中的两个相同名字的变量之间没有任何联系一般有4种: LEGB四种</p>
</blockquote>
<pre><code>locals:函数内部的名字空间，一般包括函数的局部变量以及形式参数
enclosing function:在嵌套函数中外部函数的名字空间.
globals:当前的模块空间，模块就是一些py文件。也就是说，globals()类似全局变量。
__builtins__: 内置模块空间，也就是内置变量或者内置函数的名字空间。</code></pre><p>1.当程序引用某个变量的名字时，就会从当前名字空间开始搜索。搜索顺序规则便是: LEGB。2.使用locals()访问局部命名空间，使用globals()访问全局命名空间。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/27/usage-rabbitmq/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SpaceX">
      <meta itemprop="description" content="秀外慧中流砥柱">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpaceX">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/27/usage-rabbitmq/" class="post-title-link" itemprop="url">rabbitmq使用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-08-27 20:01:36" itemprop="dateCreated datePublished" datetime="2017-08-27T20:01:36+08:00">2017-08-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Rabbitmq的基本概念"><a href="#Rabbitmq的基本概念" class="headerlink" title="Rabbitmq的基本概念"></a>Rabbitmq的基本概念</h2><h3 id="Queue（队列）"><a href="#Queue（队列）" class="headerlink" title="Queue（队列）"></a>Queue（队列）</h3><blockquote>
<p>RabbitMQ的内部对象，用于存储消息。生产者最终的消息投递到Queue中，然后消费者从Queue中获取消息并且消费。多个消费者可以订阅同一个Queue，这样的话消息会被平均分摊给消费者并处理。</p>
</blockquote>
<h3 id="Message-acknowledgment（消息回执）"><a href="#Message-acknowledgment（消息回执）" class="headerlink" title="Message acknowledgment（消息回执）"></a>Message acknowledgment（消息回执）</h3><blockquote>
<p>消费者收到Queue中的消息但是没有处理完成的话就Down机了，这种情况下可能导致消息丢失，因此需要消费者在消费完消息后发送一个回执给RabbitMQ，<br>RabbitMQ收到消息回执（Message acknowledgment）后才将消息从Queue中移除，如果RabbitMQ没有收到回执并检测到消费者的RabbitMQ链接断开，则RabbitMQ会将该消息发送给其他消费者（如果存在多个消费者进行处理的话）。<br>这里不存在timeout概念，一个消费者处理消息时间再长也不会导致该消息被发送到其他消费者，除非他的RabbitMQ链接断开。<strong><em>所以处理完之后一定要有回执（Message acknowledgment）</em></strong>。</p>
</blockquote>
<h3 id="Message-durability"><a href="#Message-durability" class="headerlink" title="Message durability"></a>Message durability</h3><blockquote>
<p>如果希望RabbitMQ服务器重启的情况下，也不想丢失数据，我们可以设置Queue和Messgae都设置为可持久化的（duration），这样可以保证绝大部分情况我们的RabbitMQ的消息不会丢失。但是依然解决不了小概率丢失时间的发生（比如RabbitMQ服务器已经接受了生产者的消息，但还是没有来得及持久化该消息的时候RabbitMQ断电了），如果需要对这种小概率时间也要管理起来，那么我们要用到事物。</p>
</blockquote>
<h3 id="Prefetch-count"><a href="#Prefetch-count" class="headerlink" title="Prefetch count"></a>Prefetch count</h3><blockquote>
<p>我们提到多个消费者同时订阅同一个Queue中的消息，Queue中的消息就会被平摊给多个消费者。这是如果每个消息的处理时间不同，就有可能会导致某些消费者一直在忙，而有些消费者很快就处理完了手头工作并且一直处于空闲的状态。我们可以通过设置PrefetchCount来限制Queue每次发送给每个消费者的消息数，比如我们设置为PrefetchCount=1，则Queue每次给每个消费者发送一条消息，消费者处理完这条消息后Queue会再给该消费者发送一条消息。</p>
</blockquote>
<h3 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h3><blockquote>
<p>我们在之前提到过生产者将消息投递到Queue中，实际上这在RabbitMQ中这种情况是永远不会发生的。实际的情况是，生产者将消息发送到Exchange（交换器），由Exchange将消费路由到一个或者多个Queue中。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;);    &#x2F;&#x2F;声明一个fanout类型的交换机</span><br></pre></td></tr></table></figure>

<h3 id="Exchange-Type"><a href="#Exchange-Type" class="headerlink" title="Exchange Type"></a>Exchange Type</h3><blockquote>
<p>RabbitMQ常用的Exchange Type有fanout,direct,topic,header这四种（AMQP规范里面还提到了两种类型分别是system和自定义）。</p>
</blockquote>
<h4 id="fanout"><a href="#fanout" class="headerlink" title="fanout"></a>fanout</h4><blockquote>
<p>fanout类型的Exchange路由规则非常简单，就是把所有发送到该Exchange的消息路由到所有与他绑定的Queue中。</p>
</blockquote>
<h4 id="direct"><a href="#direct" class="headerlink" title="direct"></a>direct</h4><blockquote>
<p>direct类型的Exchange路由规则也很简单，他会把消息路由到那些Binding Key与Routing Key完全匹配的Queue中。</p>
</blockquote>
<h4 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h4><blockquote>
<p>前面讲到direct类型的Exchange路由规则是完全匹配binding key与routing key，但这种严格的匹配方式在很多情况下不能满足实际业务需求。topic类型的Exchange在匹配规则上进行了扩展，它与direct类型的Exchage相似，也是将消息路由到binding key与routing key相匹配的Queue中，但这里的匹配规则有些不同，它约定：</p>
</blockquote>
<ul>
<li>routing key为一个句点号“. ”分隔的字符串（我们将被句点号“. ”分隔开的每一段独立的字符串称为一个单词），如“stock.usd.nyse”、“nyse.vmw”、“quick.orange.rabbit”</li>
<li>binding key与routing key一样也是句点号“. ”分隔的字符串</li>
<li>binding key中可以存在两种特殊字符“<em>”与“#”，用于做模糊匹配，其中“</em>”用于匹配一个单词，“#”用于匹配多个单词（可以是零个）</li>
</ul>
<h4 id="headers"><a href="#headers" class="headerlink" title="headers"></a>headers</h4><blockquote>
<p>headers类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。<br>在绑定Queue与Exchange时指定一组键值对；当消息发送到Exchange时，RabbitMQ会取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配Queue与Exchange绑定时指定的键值对；如果完全匹配则消息会路由到该Queue，否则不会路由到该Queue。<br>该类型的Exchange没有用到过（不过也应该很有用武之地），所以不做介绍。</p>
</blockquote>
<h3 id="Binding"><a href="#Binding" class="headerlink" title="Binding"></a>Binding</h3><blockquote>
<p>RabbitMQ中通过Binding将Exchange与Queue关联起来，这样RabbitMQ就知道如何正确的将消息路由到指定的Queue了。</p>
</blockquote>
<h3 id="Binding-Key"><a href="#Binding-Key" class="headerlink" title="Binding Key"></a>Binding Key</h3><blockquote>
<p>在绑定（Binding)Exchange与Queue的同时，一般会指定一个Binding Key（parkos.41010502111111）;<br>在绑定多个Queue到同一个Exchange的时候，这些Binding允许使用想用的Binding Key。<br>Binding Key并不是在所有情况下都生效，他依赖于Exchange Type，比如fanout类型的Exchange就会无视Binding Key，而是将消息路由到所有绑定到该Exchange的Queue。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, &quot;parkos.41010502111111&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="Routing-Key（生产者发送信息时指定，通常情况下，direct，topic类型的交换机，如果Routing-Key和Binding-Key匹配，则该队列就会获取该消息）"><a href="#Routing-Key（生产者发送信息时指定，通常情况下，direct，topic类型的交换机，如果Routing-Key和Binding-Key匹配，则该队列就会获取该消息）" class="headerlink" title="Routing Key（生产者发送信息时指定，通常情况下，direct，topic类型的交换机，如果Routing Key和Binding Key匹配，则该队列就会获取该消息）"></a>Routing Key（生产者发送信息时指定，通常情况下，direct，topic类型的交换机，如果Routing Key和Binding Key匹配，则该队列就会获取该消息）</h3><blockquote>
<p>生产者将消息发送给Exchange的时候，一般会指定一个Routing Key（parkos.41010502111111），来指定这个消息的路由规则，而这个Routing Key需要与Exchange Type和Binding Key联合使用才能最终生效。在Exchange Type与Binding Key固定的情况下（在正常使用时一般这些内容都是固定配置好的），我们的生产者就可以在发送消息给Exchange时，通过指定Routing Key来决定消息流向哪里。RabbitMQ为Routing Key设定的长度限制为255 bytes。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">this.rabbitTemplate.convertAndSend(exchange, &quot;parkos.41010502111111&quot;, message, new MessagePostProcessor() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Message postProcessMessage(Message msg) throws AmqpException &#123;</span><br><span class="line">            msg.getMessageProperties().setPriority(message.getPri());</span><br><span class="line">            return msg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, correlationData);</span><br></pre></td></tr></table></figure>

<h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4><blockquote>
<p>MQ本身是基于异步的消息处理，前面的示例中所有的生产者（P）将消息发送到RabbitMQ后不会知道消费者（C）处理成功或者失败（甚至连有没有消费者来处理这条消息都不知道）。<br>但实际的应用场景中，我们很可能需要一些同步处理，需要同步等待服务端将我的消息处理完成后再进行下一步处理。这相当于RPC（Remote Procedure Call，远程过程调用）。在RabbitMQ中也支持RPC。<br>RabbitMQ基础概念详细介绍<br>RabbitMQ中实现RPC的机制是：<br>客户端发送请求（消息）时，在消息的属性（MessageProperties，在AMQP协议中定义了14中properties，这些属性会随着消息一起发送）中设置两个值replyTo（一个Queue名称，用于告诉服务器处理完成后将通知我的消息发送到这个Queue中）和correlationId（此次请求的标识号，服务器处理完成后需要将此属性返还，客户端将根据这个id了解哪条请求被成功执行了或执行失败）<br>服务器端收到消息并处理<br>服务器端处理完消息后，将生成一条应答消息到replyTo指定的Queue，同时带上correlationId属性<br>客户端之前已订阅replyTo指定的Queue，从中收到服务器的应答消息后，根据其中的correlationId属性分析哪条请求被执行了，根据执行结果进行后续业务处理       </p>
</blockquote>
<h4 id="Virtual-hosts"><a href="#Virtual-hosts" class="headerlink" title="Virtual hosts"></a>Virtual hosts</h4><blockquote>
<p>每个virtual host本质上都是一个RabbitMQ Server，拥有它自己的queue，exchagne，和bings rule等等。这保证了你可以在多个不同的application中使用RabbitMQ。</p>
</blockquote>
<h2 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h2><h3 id="源码安装Erlang"><a href="#源码安装Erlang" class="headerlink" title="源码安装Erlang"></a>源码安装Erlang</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">yum -y install wget</span><br><span class="line">wget -c http://www.erlang.org/download/otp_src_19.2.tar.gz   (该链接务必从官网拿到,这文件不是一般的大~~)</span><br><span class="line">tar -xvf otp_src_19.2.tar.gz </span><br><span class="line">yum install gcc gcc-c++glibc-devel xz make ncurses-devel openssl-devel xmlto</span><br><span class="line">yum -y install perl ncurses-devel</span><br><span class="line"></span><br><span class="line">cd otp_src_19.2</span><br><span class="line">./configure --prefix=/opt/erlang --with-ssl -enable-threads -enable-smmp-support -enable-kernel-poll --enable-hipe --without-javac</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">vi /root/.bashrc</span><br><span class="line">添加</span><br><span class="line">export ERLANG_HOME=/opt/erlang</span><br><span class="line">export PATH=$ERLANG_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line">erl --version(查看是够安装成功,到此完成了)</span><br></pre></td></tr></table></figure>

<h3 id="rpm安装Erlang"><a href="#rpm安装Erlang" class="headerlink" title="rpm安装Erlang"></a>rpm安装Erlang</h3><blockquote>
<p>去<a href="https://github.com/rabbitmq/erlang-rpm/releases下载erlang-rpm" target="_blank" rel="noopener">https://github.com/rabbitmq/erlang-rpm/releases下载erlang-rpm</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -ivh erlang-rpm</span><br></pre></td></tr></table></figure>

<h3 id="安装和使用rabbitmq"><a href="#安装和使用rabbitmq" class="headerlink" title="安装和使用rabbitmq"></a>安装和使用rabbitmq</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://dl.bintray.com/rabbitmq/rabbitmq-server-rpm/rabbitmq-server-3.6.12-1.el7.noarch.rpm</span><br><span class="line">yum -y install socat    #安装依赖的插件</span><br><span class="line">yum -y install rabbitmq-server-3.6.12-1.el7.noarch.rpm    #至此安装成功</span><br><span class="line">systemctl enable rabbitmq-server    #开启服务</span><br><span class="line">systemctl start rabbitmq-server    #启动服务</span><br><span class="line">rabbitmqctl add_user jiege jiege    #添加用户</span><br><span class="line">rabbitmqctl set_user_tags jiege administrator    #设置角色  </span><br><span class="line">rabbitmqctl set_permissions -p "/" jiege ".*" ".*" ".*"     #赋予权限</span><br><span class="line">rabbitmq-plugins enable rabbitmq_management    #开启远程服务</span><br></pre></td></tr></table></figure>

<h3 id="消息回调"><a href="#消息回调" class="headerlink" title="消息回调"></a>消息回调</h3><blockquote>
<p>如果消息没有到exchange,则confirm回调,ack=false<br>如果消息到达exchange,则confirm回调,ack=true<br>exchange到queue成功,则不回调return<br>exchange到queue失败,则回调return(需设置mandatory=true,否则不回回调,消息就丢了)</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/17/usage-redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SpaceX">
      <meta itemprop="description" content="秀外慧中流砥柱">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpaceX">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/17/usage-redis/" class="post-title-link" itemprop="url">redis使用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-08-17 20:01:36" itemprop="dateCreated datePublished" datetime="2017-08-17T20:01:36+08:00">2017-08-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2><h3 id="第一步：创建一个文件夹redis-cluster，然后在其下面分别创建6个文件夹如下："><a href="#第一步：创建一个文件夹redis-cluster，然后在其下面分别创建6个文件夹如下：" class="headerlink" title="第一步：创建一个文件夹redis-cluster，然后在其下面分别创建6个文件夹如下："></a>第一步：创建一个文件夹redis-cluster，然后在其下面分别创建6个文件夹如下：</h3><ul>
<li>mkdir -p /usr/local/redis-cluster    </li>
<li>mkdir 7001、mkdir 7002、mkdir 7003、mkdir 7004、mkdir 7005、mkdir 7006   </li>
</ul>
<h3 id="第二步：把之前的redis-conf配置文件分别copy到700修改各个文件内容，也就是对700下的每一个copy的redis-conf文件进行修改！如下："><a href="#第二步：把之前的redis-conf配置文件分别copy到700修改各个文件内容，也就是对700下的每一个copy的redis-conf文件进行修改！如下：" class="headerlink" title="第二步：把之前的redis.conf配置文件分别copy到700修改各个文件内容，也就是对700下的每一个copy的redis.conf文件进行修改！如下："></a>第二步：把之前的redis.conf配置文件分别copy到700<em>修改各个文件内容，也就是对700</em>下的每一个copy的redis.conf文件进行修改！如下：</h3><ul>
<li>daemonize yes      </li>
<li>port 700*（分别对每个机器的端口号进行设置）         </li>
<li>bind 192.168.131.171（必须要绑定当前机器的ip，不然会无限悲剧下去哇..深坑勿入！！！）   </li>
<li>dir /usr/local/redis-cluster/700*/（指定数据文件存放位置，必须要指定不同的目录位置，不然会丢失数据，深坑勿入！！！）   </li>
<li>cluster-enabled yes（启动集群模式，开始玩耍）   </li>
<li>cluster-config-file nodes700*.conf（这里700x最好和port对应上）   </li>
<li>cluster-node-timeout 5000   </li>
<li>appendonly yes   </li>
</ul>
<h3 id="第三步：注意每个文件要修改端口号，bind的ip，数据存放的dir，并且nodes文件都需要进行修改！"><a href="#第三步：注意每个文件要修改端口号，bind的ip，数据存放的dir，并且nodes文件都需要进行修改！" class="headerlink" title="第三步：注意每个文件要修改端口号，bind的ip，数据存放的dir，并且nodes文件都需要进行修改！"></a>第三步：注意每个文件要修改端口号，bind的ip，数据存放的dir，并且nodes文件都需要进行修改！</h3><h3 id="第四步：由于redis集群需要使用ruby命令，所以我们需要安装ruby"><a href="#第四步：由于redis集群需要使用ruby命令，所以我们需要安装ruby" class="headerlink" title="第四步：由于redis集群需要使用ruby命令，所以我们需要安装ruby"></a>第四步：由于redis集群需要使用ruby命令，所以我们需要安装ruby</h3><ul>
<li>yum -y install gcc openssl-devel libyaml-devel libffi-devel readline-devel zlib-devel gdbm-devel ncurses-devel gcc-c++ automake autoconf  </li>
<li>yum -y install ruby rubygems </li>
<li>gem install redis （安装redis和ruby的接口）</li>
</ul>
<h3 id="第五步：分别启动6个redis实例，然后检查是否启动成功"><a href="#第五步：分别启动6个redis实例，然后检查是否启动成功" class="headerlink" title="第五步：分别启动6个redis实例，然后检查是否启动成功"></a>第五步：分别启动6个redis实例，然后检查是否启动成功</h3><ul>
<li>usr/local/redis/bin/redis-server /usr/local/redis-cluster/700*/redis.conf </li>
<li>ps -el | grep redis 查看是否启动成功</li>
</ul>
<h3 id="第六步：首先到redis3-0的安装目录下，然后执行redis-trib-rb命令。"><a href="#第六步：首先到redis3-0的安装目录下，然后执行redis-trib-rb命令。" class="headerlink" title="第六步：首先到redis3.0的安装目录下，然后执行redis-trib.rb命令。"></a>第六步：首先到redis3.0的安装目录下，然后执行redis-trib.rb命令。</h3><ul>
<li>cd /usr/local/redis3.0/src</li>
<li>./redis-trib.rb  create –replicas 1 192.168.131.171:7001 192.168.131.171:7002 192.168.131.171:7003 192.168.131.171:7004 192.168.131.171:7005 192.168.131.171:7006</li>
</ul>
<h3 id="第七步：到此为止我们集群搭建成功！进行验证："><a href="#第七步：到此为止我们集群搭建成功！进行验证：" class="headerlink" title="第七步：到此为止我们集群搭建成功！进行验证："></a>第七步：到此为止我们集群搭建成功！进行验证：</h3><ul>
<li>连接任意一个客户端即可：./redis-cli -c -h -p （-c表示集群模式，指定ip地址和端口号）如：/usr/local/redis/bin/redis-cli -c -h 192.168.131.171 -p 700*</li>
<li>进行验证：cluster info（查看集群信息）、cluster nodes（查看节点列表）</li>
<li>进行数据操作验证</li>
<li>关闭集群则需要逐个进行关闭，使用命令：usr/local/redis/bin/redis-cli -c -h 192.168.131.171 -p 700* shutdown</li>
</ul>
<h3 id="第八步：（补充）"><a href="#第八步：（补充）" class="headerlink" title="第八步：（补充）"></a>第八步：（补充）</h3><p>友情提示：当出现集群无法启动时，删除临时的数据文件，再次重新启动每一个redis服务，然后重新构造集群环境。</p>
<h3 id="第九步：（集群操作文章）"><a href="#第九步：（集群操作文章）" class="headerlink" title="第九步：（集群操作文章）"></a>第九步：（集群操作文章）</h3><p>redis-trib.rb官方群操作命令： <a href="http://redis.io/topics/cluster-tutorial" target="_blank" rel="noopener">链接</a></p>
<p>推荐博客：<a href="http://blog.51yip.com/nosql/1726.html/comment-page-1" target="_blank" rel="noopener">链接</a></p>
<h3 id="搭建可能遇到的问题"><a href="#搭建可能遇到的问题" class="headerlink" title="搭建可能遇到的问题"></a>搭建可能遇到的问题</h3><h4 id="ruby版本低下"><a href="#ruby版本低下" class="headerlink" title="ruby版本低下"></a>ruby版本低下</h4><p>升级方法：<a href="http://www.iyu.co/web/centos-install-ruby/" target="_blank" rel="noopener">链接</a></p>
<h2 id="redis的特性"><a href="#redis的特性" class="headerlink" title="redis的特性"></a>redis的特性</h2><h3 id="快照-rdb"><a href="#快照-rdb" class="headerlink" title="快照(rdb)"></a>快照(rdb)</h3><p>(原理:每隔n分钟或N次写入后从内存dump数据形成rdb文件压缩，放至到目录上。完成rdb快照文件的生成之后，就替换之前的旧的快照文件)<br>save 900 1    //900内,有1条写入,则产生快照<br>save 300 1000    //如果300秒内有1000次写入,则产生快照<br>save 60 10000    //如果60秒内有10000次写入,则产生快照</p>
<blockquote>
<p>NOTE:这3个选项都屏蔽,则rdb禁用<br>NOTE:新版本由新的进程(后台备份进程)导出.</p>
</blockquote>
<p>stop-writes-on-bgsave-error yes    //后台备份进程出错时,主进程停不停止写入? (rdb的导入进程出错了，redis停止写入)<br>rdbcompression yes    //导出的rdb文件是否压缩<br>Rdbchecksum yes    //导入rbd恢复时数据时,要不要检验rdb的完整性:<br>dbfilename dump.rdb    //导出来的rdb文件名<br>dir ./    //rdb的放置路径</p>
<blockquote>
<p>NOTE: 保存条件：1分钟，5分钟，15分钟才保存，所以不在里面做的修改，断电等,故障都会丢失。<br>NOTE: rdb的缺点，时间间隔内容易造成数据丢失。</p>
</blockquote>
<h3 id="日志-aof"><a href="#日志-aof" class="headerlink" title="日志(aof)"></a>日志(aof)</h3><p>(aof原理，每执行一个命令，aof进程都会将命令记录到txt文档中，写txt会严重拖慢redis。)<br>appendonly no    //是否打开 aof日志功能(yes:打开)<br>appendfsync always    //每1个命令,都立即同步到aof. 安全,速度慢<br>appendfsync everysec    //折衷方案,每秒写1次<br>appendfsync no    //写入工作交给操作系统,由操作系统判断缓冲区大小,统一写入到aof. 同步频率低,速度快,<br>no-appendfsync-on-rewrite yes:    //正在导出rdb快照的过程中,要不要停止同步aof<br>auto-aof-rewrite-percentage 100    //aof文件大小比起上次重写时的大小,增长率100%时,重写<br>auto-aof-rewrite-min-size 64mb    //aof文件,至少超过64M时,重写</p>
<h3 id="aof的fsync策略"><a href="#aof的fsync策略" class="headerlink" title="aof的fsync策略"></a>aof的fsync策略</h3><ul>
<li><p>每次写入一条数据就执行一次fsync</p>
<blockquote>
<p>每次写入一条数据，立即将这个数据对应的写日志fsync到磁盘上去，性能非常非常差，吞吐量很低; 确保说redis里的数据一条都不丢，那就只能这样了。</p>
</blockquote>
</li>
<li><p>每隔一秒执行一次fsync</p>
<blockquote>
<p>每秒将os cache中的数据fsync到磁盘，这个最常用的，生产环境一般都这么配置，性能很高，QPS还是可以上万的。</p>
</blockquote>
</li>
<li><p>不主动执行fsync</p>
<blockquote>
<p>仅仅redis负责将数据写入os cache就撒手不管了，然后后面os自己会时不时有自己的策略将数据刷入磁盘，不可控了。</p>
</blockquote>
</li>
</ul>
<h3 id="哨兵（sentinel，sentinel主要是监控主从redis是否运行正常，不正常切换主从-）"><a href="#哨兵（sentinel，sentinel主要是监控主从redis是否运行正常，不正常切换主从-）" class="headerlink" title="哨兵（sentinel，sentinel主要是监控主从redis是否运行正常，不正常切换主从.）"></a>哨兵（sentinel，sentinel主要是监控主从redis是否运行正常，不正常切换主从.）</h3><p>sentinel监控主从原理：监控主redis,如果不回应出现问题，就会将slave设为master，其他slave指向它。<br>Sentinel不断与master通信,获取master的slave信息，监听master与slave的状态。<br>如果某slave失效,直接通知master去除该slave.<br>如果master失效,,是按照slave优先级(可配置), 选取1个slave做 new master。</p>
<h3 id="主从复制流程（这个过程是异步的）"><a href="#主从复制流程（这个过程是异步的）" class="headerlink" title="主从复制流程（这个过程是异步的）"></a>主从复制流程（这个过程是异步的）</h3><ul>
<li>1、slave server启动连接到master server之后，salve server主动发送SYNC命令给master server。</li>
<li>2、master server接受SYNC命令之后，判断，是否有正在进行内存快照的子进程，如果有，则等待其结束，否则，fork一个子进程，子进程把内存数据保存为文件，并发送给slave server。</li>
<li>3、master server子进程进程做数据快照时，父进程可以继续接收client端请求写数据，此时，父进程把新写入的数据放到待发送缓存队列(backlog,默认大小是1M)中。</li>
<li>4、slave server 接收内存快照文件之后，清空内存数据，根据接收的快照文件，重建内存表数据结构。</li>
<li>5、master server把快照文件发送完毕之后，发送缓存队列中保存的子进程快照期间改变的数据给slave server，slave server做相同处理，保存数据一致性。</li>
<li>6、master server 后续接收的数据，都会通过步骤1建立的连接，把数据发送到slave server。</li>
</ul>
<p>NOTE:<br>（1）redis采用异步方式复制数据到slave节点，不过redis 2.8开始，slave node会周期性地确认自己每次复制的数据量<br>（2）一个master node是可以配置多个slave node的<br>（3）slave node也可以连接其他的slave node<br>（4）slave node做复制的时候，是不会block master node的正常工作的<br>（5）slave node在做复制的时候，也不会block对自己的查询操作，它会用旧的数据集来提供服务; 但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了<br>（6）slave node主要用来进行横向扩容，做读写分离，扩容的slave node可以提高读的吞吐量    </p>
<h3 id="异步复制导致的数据丢失（redis数据复制问题）"><a href="#异步复制导致的数据丢失（redis数据复制问题）" class="headerlink" title="异步复制导致的数据丢失（redis数据复制问题）"></a>异步复制导致的数据丢失（redis数据复制问题）</h3><blockquote>
<p>因为master -&gt; slave的复制是异步的，所以可能有部分数据还没复制到slave，master就宕机了，此时这些部分数据就丢失了</p>
</blockquote>
<h3 id="脑裂（redis数据复制问题）"><a href="#脑裂（redis数据复制问题）" class="headerlink" title="脑裂（redis数据复制问题）"></a>脑裂（redis数据复制问题）</h3><blockquote>
<p>也就是说，某个master所在机器突然脱离了正常的网络，跟其他slave机器不能连接，但是实际上master还运行着<br>此时哨兵可能就会认为master宕机了，然后开启选举，将其他slave切换成了master<br>这个时候，集群里就会有两个master，也就是所谓的脑裂<br>此时虽然某个slave被切换成了master，但是可能client还没来得及切换到新的master，还继续写向旧master的数据可能也丢失了<br>因此旧master再次恢复的时候，会被作为一个slave挂到新的master上去，自己的数据会清空，重新从新的master复制数据</p>
</blockquote>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>Q:在dump rdb过程中,aof如果停止同步,会不会丢失？</p>
<blockquote>
<p>A:不会,所有的操作缓存在内存的队列里, dump完成后,统一操作.</p>
</blockquote>
<p>Q:aof重写什么意思？</p>
<blockquote>
<p>A:aof重写是指把内存中的数据,逆化成命令,写入到.aof日志里.<br>以解决 aof日志过大的问题.（因为对同一key value操作的步骤比较多，日志比较多，但内存中就有一个最终的状态，所以重写成简单一次性命令<br>比如最终set key value.降低文件的大小。</p>
</blockquote>
<p>Q:如果rdb文件,和aof文件都存在,优先用谁来恢复数据？</p>
<blockquote>
<p>A:aof文件的完整度较高。</p>
</blockquote>
<p>Q:恢复时rdb和aof哪个恢复的快？</p>
<blockquote>
<p>A:rdb快,因为其是数据的内存映射,直接载入到内存,而aof是命令,需要逐条执行。</p>
</blockquote>
<p>Q:sentinel与master通信,如果某次因为master IO操作频繁,导致超时,此时,认为master失效,很武断，怎么办？</p>
<blockquote>
<p>A:sentnel允许多个实例看守1个master, 当N台(N可设置)sentinel都认为master失效,才正式失效。</p>
</blockquote>
<p>Q:在redis中保存几条数据，立即停掉redis进程，然后重启redis，数据还在吗？为什么？</p>
<blockquote>
<p>A:带出来一个知识点，通过redis-cli SHUTDOWN这种方式去停掉redis，其实是一种安全退出的模式，redis在退出的时候会将内存中的数据立即生成一份完整的rdb快照</p>
</blockquote>
<p>redis缓存架构<a href="https://www.jianshu.com/u/baad5ee99ca9" target="_blank" rel="noopener">链接</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/08/boot-start/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SpaceX">
      <meta itemprop="description" content="秀外慧中流砥柱">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpaceX">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/07/08/boot-start/" class="post-title-link" itemprop="url">服务端的boot程序</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-07-08 19:05:19" itemprop="dateCreated datePublished" datetime="2017-07-08T19:05:19+08:00">2017-07-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本项目举例<a href="https://gitee.com/Zalldios/spring-boot-linux.git" target="_blank" rel="noopener">链接</a></p>
<h2 id="spring-boot-windows服务端的启动"><a href="#spring-boot-windows服务端的启动" class="headerlink" title="spring-boot windows服务端的启动"></a>spring-boot windows服务端的启动</h2><ul>
<li>1 使用maven生成jar包</li>
<li>2 java -jar linuxx.jar 可跟profile文件</li>
<li>3 打包成可执行的war包<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#howto-create-a-deployable-war-file" target="_blank" rel="noopener">操作链接</a></li>
</ul>
<h2 id="spring-boot-linux服务端的启动"><a href="#spring-boot-linux服务端的启动" class="headerlink" title="spring-boot linux服务端的启动"></a>spring-boot linux服务端的启动</h2><h3 id="关闭应用的脚本：stop-sh"><a href="#关闭应用的脚本：stop-sh" class="headerlink" title="关闭应用的脚本：stop.sh"></a>关闭应用的脚本：<code>stop.sh</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">PID=$(ps -ef | grep linuxx.jar | grep -v grep | awk '&#123; print $2 &#125;')</span><br><span class="line">if [ -z "$PID" ]</span><br><span class="line">then</span><br><span class="line">    echo Application is already stopped</span><br><span class="line">else</span><br><span class="line">    echo kill $PID</span><br><span class="line">    kill $PID</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h3 id="启动应用的脚本：start-sh"><a href="#启动应用的脚本：start-sh" class="headerlink" title="启动应用的脚本：start.sh"></a>启动应用的脚本：<code>start.sh</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">nohup java -jar linuxx.jar --server.port=8888 &amp;</span><br></pre></td></tr></table></figure>

<h3 id="整合了关闭和启动的脚本：run-sh"><a href="#整合了关闭和启动的脚本：run-sh" class="headerlink" title="整合了关闭和启动的脚本：run.sh"></a>整合了关闭和启动的脚本：<code>run.sh</code></h3><p>由于会先执行关闭应用，然后再启动应用，这样不会引起端口冲突等问题，适合在持续集成系统中进行反复调用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo stop application</span><br><span class="line">source stop.sh</span><br><span class="line">echo start application</span><br><span class="line">source start.sh</span><br></pre></td></tr></table></figure>

<h2 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">APP_NAME=linuxx.jar</span><br><span class="line">usage() &#123;</span><br><span class="line">	echo "Usage: sh run.sh [start|stop|restart|status]"    </span><br><span class="line">	exit 1</span><br><span class="line">&#125; </span><br><span class="line">is_exist()&#123;  </span><br><span class="line">	pid=`ps -ef|grep $APP_NAME|grep -v grep|awk '&#123;print $2&#125;' `  </span><br><span class="line">	if [ -z "$&#123;pid&#125;" ]; then   </span><br><span class="line">		return 1  </span><br><span class="line">	else    </span><br><span class="line">		return 0  </span><br><span class="line">	fi</span><br><span class="line">&#125; </span><br><span class="line">start()&#123;  </span><br><span class="line">	is_exist  </span><br><span class="line">	if [ $? -eq "0" ]; then    </span><br><span class="line">		echo "$&#123;APP_NAME&#125; is already running. pid=$&#123;pid&#125; ."  </span><br><span class="line">	else    </span><br><span class="line">		nohup java -jar $APP_NAME &gt; /dev/null 2&gt;&amp;1 &amp;  </span><br><span class="line">	fi</span><br><span class="line">&#125; </span><br><span class="line">stop()&#123;  </span><br><span class="line">	is_exist  </span><br><span class="line">	if [ $? -eq "0" ]; then    </span><br><span class="line">		kill -9 $pid  </span><br><span class="line">	else    </span><br><span class="line">		echo "$&#123;APP_NAME&#125; is not running"  </span><br><span class="line">	fi  </span><br><span class="line">&#125; </span><br><span class="line">status()&#123;  </span><br><span class="line">	is_exist  </span><br><span class="line">	if [ $? -eq "0" ]; then    </span><br><span class="line">		echo "$&#123;APP_NAME&#125; is running. Pid is $&#123;pid&#125;"  </span><br><span class="line">	else    </span><br><span class="line">		echo "$&#123;APP_NAME&#125; is NOT running."  </span><br><span class="line">	fi</span><br><span class="line">&#125; </span><br><span class="line">restart()&#123;  </span><br><span class="line">	stop  </span><br><span class="line">	start</span><br><span class="line">&#125; </span><br><span class="line">case "$1" in  </span><br><span class="line">	"start")    </span><br><span class="line">	start    </span><br><span class="line">	;;  </span><br><span class="line">	"stop")    </span><br><span class="line">	stop    </span><br><span class="line">	;;  </span><br><span class="line">	"status")    </span><br><span class="line">	status    </span><br><span class="line">	;;  </span><br><span class="line">	"restart")    </span><br><span class="line">	restart    </span><br><span class="line">	;;  </span><br><span class="line">	*)    </span><br><span class="line">	usage    </span><br><span class="line">	;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<h2 id="开启debug"><a href="#开启debug" class="headerlink" title="开启debug"></a>开启debug</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,suspend=n -jar demo.jar</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/12/fiddler-use-common/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SpaceX">
      <meta itemprop="description" content="秀外慧中流砥柱">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpaceX">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/03/12/fiddler-use-common/" class="post-title-link" itemprop="url">fidder使用总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-12 22:02:43" itemprop="dateCreated datePublished" datetime="2017-03-12T22:02:43+08:00">2017-03-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="使用Fiddler抓取夜神模拟器"><a href="#使用Fiddler抓取夜神模拟器" class="headerlink" title="使用Fiddler抓取夜神模拟器"></a>使用Fiddler抓取夜神模拟器</h2><blockquote>
<p>1.点击Tools-Fiddler Options进入Fiddler Options页面。<br>2.点击Connections，将Fiddler listens on port设为8800，勾选Allow remote computers to connect。<br>3.点击OK，代理设置完成，重启Fiddler配置生效。<br>4.夜神模拟器点击设置，进入到wifi连接选项。<br>5.点击wifi进入wifi选项，长按热点，出现修改网络的弹窗。<br>6.点击修改网络，勾选高级选项,将代理设为手动，代理服务器主机名填写电脑的ip，端口号填写8800。<br>7.点击保存。（和我们手机客户端原理一样）搜索OnBeforeRequest关键字。</p>
</blockquote>
<h2 id="修改请求头Host"><a href="#修改请求头Host" class="headerlink" title="修改请求头Host"></a>修改请求头Host</h2><blockquote>
<p>现在微服务提的比较广泛，业务会拆分为很多的服务模块，如果想测试一个服务但是需要其他服务的支持（比如一般情况下需要登录才可以查看对应活动，假设对活动模块进行了拆分），是不是需要你本地把所有的服务都启动起来？<br>这显然是不现实的，下面fiddler中的一种方法可以进行模块的分离测试，主要原理就是针对远程服务的IP替换为本机的IP，这样对应服务就会从本地访问来获取数据。<br>工具栏查找 Rules &gt; Customize Rules<br>找到OnBeforeRequest方法在方法开头添加以下代码。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oSession.host.toLowerCase()== <span class="string">'alldios.com'</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      oSession.host=<span class="string">'192.168.0.110:8882'</span>;</span><br><span class="line">      oSession[<span class="string">"ui-color"</span>] = <span class="string">"orange"</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/22/java-thread&pool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SpaceX">
      <meta itemprop="description" content="秀外慧中流砥柱">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpaceX">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/01/22/java-thread&pool/" class="post-title-link" itemprop="url">java线程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-01-22 09:07:21" itemprop="dateCreated datePublished" datetime="2017-01-22T09:07:21+08:00">2017-01-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="线程的六种状态"><a href="#线程的六种状态" class="headerlink" title="线程的六种状态:"></a>线程的六种状态:</h2><h3 id="NEW"><a href="#NEW" class="headerlink" title="NEW"></a>NEW</h3><p>线程刚创建, 尚未启动</p>
<h3 id="RUNNABLE"><a href="#RUNNABLE" class="headerlink" title="RUNNABLE"></a>RUNNABLE</h3><p>线程正在虚拟机正常运行中, 当然可能会有某种耗时计算/IO等待的操作/CPU时间片切换等, 这个状态下发生的等待一般是其他系统资源, 而不是锁, Sleep等</p>
<h3 id="BLOCKED"><a href="#BLOCKED" class="headerlink" title="BLOCKED"></a>BLOCKED</h3><p>这个状态下, 是在多个线程有同步操作的场景, 比如正在等待另一个线程的 synchronized 块的执行释放, 或者可重入的 synchronized 块里别人调用wait() 方法, 也就是这里是线程在等待进入临界区</p>
<h3 id="WAITING"><a href="#WAITING" class="headerlink" title="WAITING"></a>WAITING</h3><p>这个状态下是指线程拥有了某个锁之后, 调用了他的wait方法, 等待其他线程/锁拥有者调用 notify / notifyAll 一遍该线程可以继续下一步操作,<br> 这里要区分 BLOCKED 和 WATING 的区别, <strong>一个是在临界点外面等待进入, 一个是在临界点里面wait等待别人notify</strong>， 线程调用了另外一个线程（THREAD-OTHER）的join方法, 也会进入WAITING状态, 等待（THREAD-OTHER）的线程执行结束</p>
<h3 id="TIMED-WAITING"><a href="#TIMED-WAITING" class="headerlink" title="TIMED_WAITING"></a>TIMED_WAITING</h3><p>这个状态就是有限的(时间限制)的WAITING, 一般出现在调用wait(long), join(long)等情况下, 另外情况就是一个线程sleep后, 也会进入TIMED_WAITING状态</p>
<h3 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h3><p>这个状态下表示 该线程的run方法已经执行完毕了, 基本上就等于死亡了(当时如果线程被持久持有, 可能不会被回收)</p>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>deamon是一种运行在后台的一种特殊的进程，它独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。由于在Linux中，<strong>每个系统与用户进行交流的界面成为终端</strong>，每一个从此终端开始运行的进程都会依附于这个终端，这个终端被称为这些进程的控制终端，当控制终端被关闭的时候，相应的进程都会自动关闭。<br>但是守护进程却能突破这种限制，它脱离于终端并且在后台运行，并且它脱离终端的目的是为了避免进程在运行的过程中的信息在任何终端中显示并且进程也不会被任何终端所产生的终端信息所打断。它从被执行的时候开始运转，直到整个系统关闭才退出(当然可以人为的杀死相应的守护进程)。如果想让某个进程不因为用户或中断或其他变化而影响，那么就必须把这个进程变成一个守护进程。</p>
<h3 id="守护线程和非守护线程"><a href="#守护线程和非守护线程" class="headerlink" title="守护线程和非守护线程"></a>守护线程和非守护线程</h3><p>Daemon的作用是为其他线程的运行提供服务，比如说GC线程。User Thread线程和Daemon Thread守护线程本质上来说去没啥区别，唯一的区别之处就在虚拟机的离开：如果User Thread全部撤离，那么Daemon Thread也就没啥线程好服务的了，所以虚拟机也就退出了。</p>
<ul>
<li>1）、thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。  （备注：这点与守护进程有着明显的区别，守护进程是创建后，让进程摆脱原会话的控制+让进程摆脱原进程组的控制+让进程摆脱原控制终端的控制；所以说寄托于虚拟机的语言机制跟系统级语言有着本质上面的区别）</li>
<li>2）、在Daemon线程中产生的新线程也是Daemon的。  （这一点又是有着本质的区别了：守护进程fork()出来的子进程不再是守护进程，尽管它把父进程的进程相关信息复制过去了，但是子进程的进程的父进程不是init进程，所谓的守护进程本质上说就是“父进程挂掉，init收养，然后文件0,1,2都是/dev/null，当前目录到/”）</li>
</ul>
<h2 id="Java通过Executors提供四种线程池，分别为："><a href="#Java通过Executors提供四种线程池，分别为：" class="headerlink" title="Java通过Executors提供四种线程池，分别为："></a>Java通过Executors提供四种线程池，分别为：</h2><h3 id="1、newCachedThreadPool"><a href="#1、newCachedThreadPool" class="headerlink" title="1、newCachedThreadPool"></a>1、newCachedThreadPool</h3><p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。（线程最大并发数不可控制）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、newFixedThreadPool"><a href="#2、newFixedThreadPool" class="headerlink" title="2、newFixedThreadPool"></a>2、newFixedThreadPool</h3><p>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、newScheduledThreadPool"><a href="#3、newScheduledThreadPool" class="headerlink" title="3、newScheduledThreadPool"></a>3、newScheduledThreadPool</h3><p>创建一个定长线程池，支持定时及周期性任务执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">              <span class="keyword">new</span> DelayedWorkQueue())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、newSingleThreadExecutor"><a href="#4、newSingleThreadExecutor" class="headerlink" title="4、newSingleThreadExecutor"></a>4、newSingleThreadExecutor</h3><p>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ThreadPoolExecutor的构造方法参数"><a href="#ThreadPoolExecutor的构造方法参数" class="headerlink" title="ThreadPoolExecutor的构造方法参数"></a>ThreadPoolExecutor的构造方法参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,    </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,    </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,    </span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,    </span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,    </span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,    </span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="构造方法参数解释"><a href="#构造方法参数解释" class="headerlink" title="构造方法参数解释"></a>构造方法参数解释</h3><ul>
<li>1 corePoolSize 维持的最小的活动线程的数量<br>当提交一个任务到线程池时，如果总线程数量小于corePoolSize，线程会继续创建新线程来执行任务。除非您设置了allowCoreThreadTimeOut属性（默认为false）。</li>
<li>2 maximumPoolSize 线程池的最大数量<br>所需线程数大于corePoolSize<code>&amp;&amp;</code>阻塞队列已满 会继续创建线程直到maximumPoolSize </li>
<li>3 keepAliveTime 空闲线程存活时间<br>如果当前线程数量大于corePoolSize，超出的<code>&amp;&amp;</code>空闲时间大于keepAliveTime的 则会终止。</li>
<li>4 unit 时间单位  </li>
<li>5 workQueue 任务队列<br>用于保存等待执行的任务的阻塞队列。一个阻塞队列，用来存储等待执行的任务</li>
<li>6 threadFactory 用于设置创建线程的工厂<br>可以通过线程工厂给每个创建出来的线程设置更有意义的名字</li>
<li>7 handler 饱和策略（四种ThreadPoolExcutor的饱和策略）<br>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。<br>ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。<br>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）<br>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</li>
</ul>
<h3 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h3><p>当提交一个任务到线程池时它的执行流程是怎样的呢？</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fnbzmai8yrj30dw08574s.jpg" alt=""></p>
<blockquote>
<p>首先第一步会判断核心线程数有没有达到上限，如果没有则创建线程(会获取全局锁)，满了则会将任务丢进阻塞队列。<br>如果队列也满了则需要判断最大线程数是否达到上限，如果没有则创建线程(获取全局锁)，如果最大线程数也满了则会根据饱和策略处理。<br>常用的饱和策略有:  </p>
</blockquote>
<ul>
<li>直接丢弃任务。     </li>
<li>调用者线程处理。     </li>
<li>丢弃队列中的最近任务，执行当前任务。<br>所以当线程池完成预热之后都是将任务放入队列，接着由工作线程一个个从队列里取出执行。     </li>
</ul>
<h2 id="合理配置线程池"><a href="#合理配置线程池" class="headerlink" title="合理配置线程池"></a>合理配置线程池</h2><blockquote>
<p>线程池并不是配置越大越好，而是要根据任务的熟悉来进行划分：<br>如果是 <code>CPU</code> 密集型任务应当分配较少的线程，比如 <code>CPU</code> 个数相当的大小。<br>如果是 IO 密集型任务，IO操作不占用CPU，线程并不是一直在运行，所以可以尽可能的多配置线程，比如 <code>CPU 个数 * 2</code> 。<br>当是一个混合型任务，可以将其拆分为 <code>CPU</code> 密集型任务以及 <code>IO</code> 密集型任务，这样来分别配置。<br>在《linux多线程服务器端编程》中有一个思路，CPU计算和IO的阻抗匹配原则。<br>如果线程池中的线程在执行任务时，密集计算所占的时间比重为P(0&lt;P&lt;=1)，而系统一共有C个CPU，为了让CPU跑满而又不过载，线程池的大小经验公式 T = C / P。<br>在此，T只是一个参考，考虑到P的估计并不是很准确，T的最佳估值可以上下浮动50%。<br>这个经验公式的原理很简单，T个线程，每个线程占用P的CPU时间，如果刚好占满C个CPU,那么必有 T * P = C。<br>下面验证一下边界条件的正确性：<br>假设C = 8，P = 1.0，线程池的任务完全是密集计算，那么T = 8。只要8个活动线程就能让8个CPU饱和，再多也没用了，因为CPU资源已经耗光了。<br>假设C = 8，P = 0.5，线程池的任务有一半是计算，有一半在等IO上，那么T = 16.考虑操作系统能灵活，合理调度sleeping/writing/running线程，那么大概16个“50%繁忙的线程”能让8个CPU忙个不停。<br>启动更多的线程并不能提高吞吐量，反而因为增加上下文切换的开销而降低性能。<br>如果P &lt; 0.2，这个公式就不适用了，T可以取一个固定值，比如 5<em>C。另外公式里的C不一定是CPU总数，可以是“分配给这项任务的CPU数目”，比如在8核机器上分出4个核来做一项任务，那么C=4<br>文章如何合理设置线程池大小里面提到了一个公式：<br>最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）</em> CPU数目<br>比如平均每个线程CPU运行时间为0.5s，而线程等待时间（非CPU运行时间，比如IO）为1.5s，CPU核心数为8，那么根据上面这个公式估算得到：((0.5+1.5)/0.5)<em>8=32。这个公式进一步转化为：<br>最佳线程数目 = （线程等待时间与线程CPU时间之比 + 1）</em> CPU数目<br>可以得出一个结论：<br>线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。<br>以上公式与之前的CPU和IO密集型任务设置线程数基本吻合    </p>
</blockquote>
<h2 id="另外的线程池类型"><a href="#另外的线程池类型" class="headerlink" title="另外的线程池类型"></a>另外的线程池类型</h2><h3 id="ScheduledExecutorService（调度线程池）"><a href="#ScheduledExecutorService（调度线程池）" class="headerlink" title="ScheduledExecutorService（调度线程池）"></a>ScheduledExecutorService（调度线程池）</h3><blockquote>
<p>该线程池致力于定时执行的任务，比如心跳类型的任务。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService executor = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">    Runnable task = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"...........HeartBeat..........."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">executor.scheduleAtFixedRate(task, <span class="number">5</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/16/seo-optimization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SpaceX">
      <meta itemprop="description" content="秀外慧中流砥柱">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpaceX">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/01/16/seo-optimization/" class="post-title-link" itemprop="url">搜索引擎优化总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-01-16 09:25:45" itemprop="dateCreated datePublished" datetime="2017-01-16T09:25:45+08:00">2017-01-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>企业产品或服务抢占搜索引擎中的靠前排名，就意味着抢占了网络的至高点。也等同于捡钱。SEO（搜索引擎优化）是推广中最低价、最有效、最持久的方式。<br>搜索引擎优化的英文全称是：Search engine optimization，是一种可以让网站在搜索引擎上表现的更好的技术。<br>遵循搜索引擎科学而全面的理论机制，<br>对网站结构、网页文字语言和站点间的互动外交策略等进行合理规划部署来发掘网站的最大潜力而使其在搜索引擎中具有较强的自然排名竞争优势，<br>从而对促进企业在线销售和强化网络品牌起到作用。<br>站点访问量的第一来源是搜索引擎。<br>搜索引擎是目前为止用户寻找信息、产品、服务的最主要的方式，网站将近90%的流量来自搜索引擎。<br>搜索引擎优化作为网站推广的一种方式较其他形式的线上或线下而言是投资回报率最好的。<br> 传统的广告形式只是将您的产品或服务给潜在客户带来一种视觉冲击，然而搜索引擎却能给您真正带来买家。因此搜索引擎优化可以说是目前最好的网站推广方式。    </p>
<p>一个很详细的<a href="http://www.vuln.cn/baike/pachong" target="_blank" rel="noopener">seo优化</a>链接</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/19/semaphore-mechanism-in-sync/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SpaceX">
      <meta itemprop="description" content="秀外慧中流砥柱">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpaceX">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/19/semaphore-mechanism-in-sync/" class="post-title-link" itemprop="url">同步之中的信号量机制</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-19 13:58:23" itemprop="dateCreated datePublished" datetime="2016-12-19T13:58:23+08:00">2016-12-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>为实现进程互斥进入自己临界区，所有同步机制应该遵循下述四条原则<br>空闲让进：当无进程进入临界区，表明临界资源正处于空闲状态，应允许一个请求进入临界区的进程立即进入临界区。<br>忙则等待：当已有进程进入了临界区，表明临界区资源正在被访问，因而其他试图进入临界区的进程必须等待。<br>有限等待：对要求访问临界区资源的进程，应保证在有限时间内进入自己的临界区，以免进入<code>死等</code>状态。<br>让权等待：当进程不能使用自己的临界区时，应立即释放处理机，以免进程进入<code>忙等</code>的状态。</p>
</blockquote>
<h3 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h3><p>定义为一个表示资源数目的整形量S，与一般整形量不同，他只能够通过两个标准的原子操作wait(S)，和signal(S)进行访问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wait(S):   <span class="keyword">while</span> S&lt;=<span class="number">0</span> <span class="keyword">do</span> no-operation #循环判断如果资源已经被耗尽，则什么都不做。</span><br><span class="line">           S:=S<span class="number">-1</span> #如果还有资源，则进行信号量 减一 操作。</span><br><span class="line">signal(S): S:=S+<span class="number">1</span> #如果使用完毕，则进行信号量 加一 操作。</span><br></pre></td></tr></table></figure>

<h3 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h3><p>我们可以观察到在整型信号量中，出现了一直循环的现象，并没有遵循让权等待的原则。记录型信号量，使用了一个记录型的数据结构。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type semaphore=record</span><br><span class="line">    value:integer #资源的数量值</span><br><span class="line">    L:<span class="built_in">list</span> of <span class="built_in">process</span> #进程的等待队列</span><br><span class="line">    <span class="built_in">end</span></span><br><span class="line">procedure wait(S) #请求操作</span><br><span class="line">	var S:semaphore;                          </span><br><span class="line">	<span class="built_in">begin</span></span><br><span class="line">	  S.value:=S.value<span class="number">-1</span>; #进行 减一 操作</span><br><span class="line">	  <span class="keyword">if</span> S.value&lt;<span class="number">0</span> <span class="function">then <span class="title">block</span><span class="params">(S.L)</span></span>; #如果资源已经小于零，则阻塞，并且添加到等待队列。则是S的绝对值代表了阻塞队列的长度。</span><br><span class="line">	<span class="built_in">end</span></span><br><span class="line">procedure signal(S) #释放操作</span><br><span class="line">	var S:semaphore;</span><br><span class="line">	<span class="built_in">begin</span></span><br><span class="line">	  S.value:=S.value+<span class="number">1</span>; #进行 加一 操作。</span><br><span class="line">	  <span class="keyword">if</span> S.value&lt;=<span class="number">0</span> then wakeup(S.L); #如果等待队列中还有等待进程，则唤醒一个等待队列的线程继续执行。</span><br><span class="line">    <span class="built_in">end</span></span><br></pre></td></tr></table></figure>

<h3 id="AND型信号量"><a href="#AND型信号量" class="headerlink" title="AND型信号量"></a>AND型信号量</h3><p>如果一个进程需要一次性同时访问多个资源的话，上述的两种信号量都不可以解决。AND信号量的核心就是要么一次性全部分配，要么一个都不分配。那么如下（simultaneous）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Swait(S1,S2,S3...Sn)</span><br><span class="line">   <span class="keyword">if</span>(S1&gt;=<span class="number">1</span>&amp;S2&gt;=<span class="number">1</span>&amp;S3&gt;=<span class="number">1</span>&amp;S4&gt;=<span class="number">1</span>) then</span><br><span class="line">     <span class="keyword">for</span> i:=<span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">     Si=Si<span class="number">-1</span>;</span><br><span class="line">     endfor</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   如果第一个Si资源不足，将进程放置在Si相关联的等待队列，继续执行Swait操作。</span><br><span class="line">   endif</span><br><span class="line">Ssingal(S1,S2,S3...Sn)</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">  Si:=Si+<span class="number">1</span>;</span><br><span class="line">  移交所有与Si相关的等待队列的进程到就绪队列。</span><br><span class="line">  endfor;</span><br></pre></td></tr></table></figure>

<h3 id="信号量集"><a href="#信号量集" class="headerlink" title="信号量集"></a>信号量集</h3><p>上述所有的信号量机制都是对信号量进行加一或者减一的操作，意味着每次只能获得和释放一个单位的临界资源。如果需要N个某类的临界资源时候，需要进行N此的wait(S)操作。这是比较低效的，并且当资源的某一数量小于某值的情况后便不予以分配。因为在每次分配之前都需要测试数量是否足够。<br>那么我们假设 S为信号量，d为需求值，t为下限值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Swait(S1,t1,d1,...Sn,tn,dn)</span><br><span class="line">   <span class="keyword">if</span>(S1&gt;=t1 &amp; Sn&gt;=tn) then</span><br><span class="line">     <span class="keyword">for</span> i:=<span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">     Si=Si-di;</span><br><span class="line">     endfor</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   如果第一个Si资源不足，将进程放置在Si相关联的等待队列，继续执行Swait操作。</span><br><span class="line">   endif</span><br><span class="line">Ssingal(S1,t1,d1,...Sn,tn,dn)</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">  Si:=Si+di;</span><br><span class="line">  移交所有与Si相关的等待队列的进程到就绪队列。</span><br><span class="line">  endfor;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/20/sql-oracle-materialized-view/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SpaceX">
      <meta itemprop="description" content="秀外慧中流砥柱">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpaceX">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/11/20/sql-oracle-materialized-view/" class="post-title-link" itemprop="url">oracle物化视图的使用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-11-20 09:09:38" itemprop="dateCreated datePublished" datetime="2016-11-20T09:09:38+08:00">2016-11-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="物化视图的类型："><a href="#物化视图的类型：" class="headerlink" title="物化视图的类型："></a>物化视图的类型：</h3><p>on demand、on commit 二者的区别在于刷新方法的不同<br>on demand顾名思义，仅在该物化视图“需要”被刷新了，才进行刷新(refresh)，即更新物化视图，以保证和基表数据的一致性；<br>而on commit是说，一旦基表有了commit，即事务提交，则立刻刷新，立刻更新物化视图，使得数据和基表一致。</p>
<h3 id="on-demand物化视图"><a href="#on-demand物化视图" class="headerlink" title="on demand物化视图"></a>on demand物化视图</h3><p>物化视图的创建本身是很复杂和需要优化参数设置的，特别是针对大型生产数据库系统而言。<br>但oracle允许以这种最简单的，类似于普通视图的方式来做，所以不可避免的会涉及到默认值问题。<br>也就是说oracle给物化视图的重要定义参数的默认值处理是我们需要特别注意的。</p>
<p>物化视图的特点：<br>(1) 物化视图在某种意义上说就是一个物理表(而且不仅仅是一个物理表)，这通过其可以被user_tables查询出来，而得到佐证；<br>(2) 物化视图也是一种段(segment)，所以其有自己的物理存储属性；<br>(3) 物化视图会占用数据库磁盘空间，这点从user_segment的查询结果，可以得到佐证；<br>创建语句：create materialized view mv_name as select * from table_name<br>默认情况下，如果没指定刷新方法和刷新模式，则oracle默认为force和demand。</p>
<h3 id="on-commit物化视图"><a href="#on-commit物化视图" class="headerlink" title="on commit物化视图"></a>on commit物化视图</h3><p>on commit物化视图的创建，和上面创建on demand的物化视图区别不大。因为on demand是默认的，所以on commit物化视图，需要再增加个参数即可。<br>需要注意的是，无法在定义时仅指定on commit，还得附带个参数才行。<br>创建on commit物化视图：create materialized view mv_name refresh force on commit as select * from table_name  </p>
<h3 id="物化视图的刷新"><a href="#物化视图的刷新" class="headerlink" title="物化视图的刷新"></a>物化视图的刷新</h3><p>刷新（refresh）：指当基表发生了dml操作后，物化视图何时采用哪种方式和基表进行同步。<br>刷新的模式有两种：on demand和on commit。（如上所述）<br>刷新的方法有四种：fast、complete、force和never。<br>fast刷新采用增量刷新，只刷新自上次刷新以后进行的修改。<br>complete刷新对整个物化视图进行完全的刷新。<br>如果选择force方式，则oracle在刷新时会去判断是否可以进行快速刷新，如果可以则采用fast方式，否则采用complete的方式。<br>never指物化视图不进行任何刷新。<br>对于已经创建好的物化视图，可以修改其刷新方式，比如把物化视图mv_name的刷新方式修改为每天晚上10点刷新一次：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">materialized</span> <span class="keyword">view</span> mv_name <span class="keyword">refresh</span> <span class="keyword">force</span> <span class="keyword">on</span> <span class="keyword">demand</span> <span class="keyword">start</span> <span class="keyword">with</span> <span class="keyword">sysdate</span> <span class="keyword">next</span> <span class="keyword">to_date</span>(<span class="keyword">concat</span>(to_char(<span class="keyword">sysdate</span>+<span class="number">1</span>,<span class="string">'dd-mm-yyyy'</span>),<span class="string">' 22:00:00'</span>),<span class="string">'dd-mm-yyyy hh24:mi:ss'</span>)</span><br><span class="line">-或者job使用存储过程当时刷新，两者相差无几。先创建存储过程</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">procedure</span> p_refresh_stats <span class="keyword">is</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  dbms_mview.refresh(<span class="string">'mv_name'</span>, <span class="string">'c'</span>);</span><br><span class="line"><span class="keyword">end</span> p_refresh_stats;</span><br><span class="line">-然后创建job执行该存储过程</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  sys.dbms_scheduler.create_job(job_name            =&gt; <span class="string">'bjd_branch.job_refresh_stats'</span>,</span><br><span class="line">                                job_type            =&gt; <span class="string">'stored_procedure'</span>,</span><br><span class="line">                                job_action          =&gt; <span class="string">'p_refresh_stats'</span>,</span><br><span class="line">                                start_date          =&gt; <span class="keyword">to_date</span>(<span class="string">'01-07-2016 00:00:00'</span>, <span class="string">'dd-mm-yyyy hh24:mi:ss'</span>),</span><br><span class="line">                                repeat_interval     =&gt; <span class="string">'freq=hourly;interval=1'</span>,</span><br><span class="line">                                end_date            =&gt; <span class="keyword">to_date</span>(<span class="string">'01-07-2022 00:00:00'</span>, <span class="string">'dd-mm-yyyy hh24:mi:ss'</span>),</span><br><span class="line">                                job_class           =&gt; <span class="string">'default_job_class'</span>,</span><br><span class="line">                                enabled             =&gt; <span class="literal">true</span>,</span><br><span class="line">                                auto_drop           =&gt; <span class="literal">false</span>,</span><br><span class="line">                                comments            =&gt; <span class="string">''</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<h3 id="物化视图具有表一样的特征"><a href="#物化视图具有表一样的特征" class="headerlink" title="物化视图具有表一样的特征"></a>物化视图具有表一样的特征</h3><p>所以可以像对表一样，我们可以为它创建索引，创建方法和对表一样。</p>
<h3 id="物化视图的删除"><a href="#物化视图的删除" class="headerlink" title="物化视图的删除"></a>物化视图的删除</h3><p>虽然物化视图是和表一起管理的，但是在经常使用的oplsql工具中，并不能用删除表的方式来删除<br>（在表上右键选择‘drop’并不能删除物化视图），可以使用语句来实现：drop materialized view mv_name</p>
<h3 id="普通视图和物化视图的区别"><a href="#普通视图和物化视图的区别" class="headerlink" title="普通视图和物化视图的区别"></a>普通视图和物化视图的区别</h3><p>普通视图和物化视图根本就不是一个东西，说区别都是硬拼到一起的，<br>首先明白基本概念，普通视图是不存储任何数据的，他只有定义，在查询中是转换为对应的定义sql去查询，<br>而物化视图是将数据转换为一个表，实际存储着数据，这样查询数据，就不用关联一大堆表，如果表很大的话，会在临时表空间内做大量的操作。</p>
<p>普通视图的三个特征：<br>1、是简化设计，清晰编码的东西，他并不是提高性能的，他的存在只会降低性能<br>（如一个视图7个表关联，另一个视图8个表，程序员不知道，觉得很方便，把两个视图关联再做一个视图，那就惨了），他的存在未了在设计上的方便性</p>
<p>2、其次，是安全，在授权给其他用户或者查看角度，多个表关联只允许查看，不允许修改，<br>单表也可以同with read only来控制，当然有些项目基于视图做面向对象的开发，即在视图上去做instand of触发器，就我个人而言是不站同的，虽然开发上方便，但是未必是好事。</p>
<p>3、从不同的角度看不同的维度，视图可以划分维度和权限，并使多个维度的综合，也就是你要什么就可以从不同的角度看，而表是一个实体的而已，<br>一般维度较少（如：人员表和身份表关联，从人员表可以查看人员的维度统计，从身份看，可以看不同种类的身份有那些人或者多少人），<br>其次另一个如系统视图user_table、tab、user_objects这些视图，不同的用户下看到的肯定是不一样的，看的是自己的东西。<br>物化视图呢，用于olap系统中，当然部分oltp系统的小部分功能未了提高性能会借鉴一点点，因为表关联的开销很大，所以在开发中很多人就像把这个代价交给定期转存来完成，<br>oracle当然也提供了这个功能，就是将视图（或者一个大sql）的信息转换为物理数据存储，然后提供不同的策略：<br>定时刷还是及时刷、增量刷还是全局刷等等可以根据实际情况进行选择，总之你差的是表，不是视图。</p>
<p>关于在刷新和索引上的区别<br>他们两个没有联系吧，刷新我不清楚你是否指的是物化视图的刷新，因为刷新的概念很泛，你说到这里我就理解为物化视图的刷新了，<br>上面也已经说了，这是一种策略和方法，其实它是通过对视图关联表上创建相应的log，根据日志信息的sql同步到物化视图中的，<br>一般来说：定时的一般是全局刷，及时的一般是局部刷。</p>
<p>而索引这个说起来就多了，可以说索引专门是一门课程，大概点来说，索引一般有普通索引、位图索引、唯一性索引（还有全文索引啥的，一般不用），<br>其实仔细研究会发现无论是那一种索引都是b+树为基础，并起存放方式和表一样，是以段为单位，只是内部有树关系而已。</p>
<p>1、普通索引是根据b+树找到第一个（索引时有序的），然后以当前为基准，向后顺序找到不符合条件的健值为止。<br>2、位图是在叶子节点上根据位图种类对叶子节点的值进行01编码存放（如该字段有1、2、3三种值，就会在叶子节点上有三个位图，<br>每个位图根据健值和rowid顺序存放是否为1、是否为2、是否为3，所以在rbo下统计很快，cbo下一般会认为是普通索引）。</p>
<p>3、也是按照b+树找，只是找到就不再做任何操作，因为是唯一的。<br>因为b+查找是一个类似表的查询，而且获取到rowid后还是要回表查询的，所以这个过程的开销要和全表扫描计算那个结果更加快，oracle才会选择是走索引还是走全表扫描，<br>当然对于cbo和rbo选择的方式不一样，具体又是很多，cbo要依赖于表的统计信息，rbo是依赖于尝试。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/28/linux-cmd-tee/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SpaceX">
      <meta itemprop="description" content="秀外慧中流砥柱">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpaceX">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/09/28/linux-cmd-tee/" class="post-title-link" itemprop="url">tee命令使用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-09-28 17:22:24" itemprop="dateCreated datePublished" datetime="2016-09-28T17:22:24+08:00">2016-09-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>tee命令用于将数据重定向到文件，另一方面还可以提供一份重定向数据的副本作为后续命令的stdin。简单的说就是把数据重定向到给定文件和屏幕上。</p>
<p>列如 <code>ls -l |tee file.txt|cat</code></p>
<p>tee和echo类似，可以把打印内容输入到一个文件，常和<code>&lt;&lt;</code>使用<br><code>&lt;&lt;</code>字符表示从命令行读取输入，直到一个与&lt;&lt; 所跟内容相同的字符结束</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@alldios~]#tee /etc/yum.repos.d/docker.repo &lt;&lt;-'EOF'  #创建一个文件，内容就是下面命令行EOF之前的输入。</span><br><span class="line">[dockerrepo]</span><br><span class="line">name=Docker Repository</span><br><span class="line">baseurl=https://yum.dockerproject.org/repo/main/centos/7/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://yum.dockerproject.org/gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SpaceX"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">SpaceX</p>
  <div class="site-description" itemprop="description">秀外慧中流砥柱</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:alldios@foxmail.com" title="E-Mail → mailto:alldios@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.instagram.com/_heart_k/" title="Instagram → https:&#x2F;&#x2F;www.instagram.com&#x2F;_heart_k&#x2F;" rel="noopener" target="_blank"><i class="fa fa-fw fa-instagram"></i>Instagram</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://gitee.com/Zalldios" title="Gitee → https:&#x2F;&#x2F;gitee.com&#x2F;Zalldios" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>Gitee</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/ChaojieDZhao" title="Github → https:&#x2F;&#x2F;github.com&#x2F;ChaojieDZhao" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>Github</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SpaceX</span>
</div>

<a href="http://www.beian.miit.gov.cn/"  style="color:#f72b07" target="_blank">豫ICP备16002676号-1</a>
        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  

</body>
</html>
